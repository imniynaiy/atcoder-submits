{
    "GRAPH": {
        "prefix": "GRAPH",
        "body": [
            "template <class T>",
            "struct Edge {",
            "  int from, to;",
            "  T cost;",
            "",
            "  Edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}",
            "",
            "  explicit operator int() const { return to; }",
            "",
            "  bool operator<(const Edge &rhs) const { return cost < rhs.cost; }",
            "};",
            "",
            "template <class T>",
            "using Edges = vector<Edge<T>>;",
            "",
            "template <class T>",
            "using WeightedGraph = vector<Edges<T>>;",
            "",
            "using UnWeightedGraph = vector<vector<int>>;",
            "",
            "template <class T>",
            "using DistMatrix = vector<vector<T>>;",
            "",
            "struct GraphAdapter {",
            "  template <class T>",
            "  static UnWeightedGraph to_unweighted_graph(const WeightedGraph<T> &origin) {",
            "    int V = origin.size();",
            "    UnWeightedGraph graph(V);",
            "    for (int i = 0; i < V; i++)",
            "      for (auto &e : origin[i]) graph[i].push_back((int)e);",
            "    return graph;",
            "  }",
            "",
            "  static WeightedGraph<int> to_weighted_graph(const UnWeightedGraph &origin) {",
            "    int V = origin.size();",
            "    WeightedGraph<int> graph(V);",
            "    for (int i = 0; i < V; i++)",
            "      for (auto to : origin[i]) graph[i].push_back({i, to, 1});",
            "    return graph;",
            "  }",
            "",
            "  template <class T>",
            "  static DistMatrix<T> to_dist_matrix(const WeightedGraph<T> &origin, T INF) {",
            "    int V = origin.size();",
            "    DistMatrix<T> matrix(V, vector<T>(V, INF));",
            "    for (int i = 0; i < V; i++)",
            "      for (auto &e : origin[i]) matrix[i][e.to] = e.cost;",
            "    for (int i = 0; i < V; i++) matrix[i][i] = 0;",
            "    return matrix;",
            "  }",
            "};"
        ],
        "description": "description for GRAPH"
    },
    "BFS": {
        "prefix": "BFS",
        "body": [
            "class BFS_DIJKSTRA {",
            " private:",
            "  int V;",
            "  const UnWeightedGraph &G;",
            "  const int INF = 1e8;",
            "  vector<int> dist;",
            "",
            " public:",
            "  BFS_DIJKSTRA(const UnWeightedGraph &G) : G(G), V(G.size()) {}",
            "",
            "  vector<int> get_dist(int s) {",
            "    dist = vector<int>(V, INF);",
            "    dist[s] = 0;",
            "    queue<int> Q;",
            "    Q.push(s);",
            "    while (!Q.empty()) {",
            "      int v = Q.front();",
            "      Q.pop();",
            "      for (auto to : G[v]) {",
            "        if (dist[to] == INF) {",
            "          dist[to] = dist[v] + 1;",
            "          Q.push(to);",
            "        }",
            "      }",
            "    }",
            "    return dist;",
            "  }",
            "};"
        ],
        "description": "description for BFS"
    },
    "BI_COMB": {
        "prefix": "BI_COMB",
        "body": [
            "template <class T>",
            "struct BI_COMB {",
            "  vector<T> fact_, inv_;",
            "  constexpr BI_COMB() {}",
            "  constexpr BI_COMB(long long n) : fact_(n, 1), inv_(n, 1) { init(n); }",
            "  constexpr void init(int n) {",
            "    fact_.assign(n, 1);",
            "    inv_.assign(n, 1);",
            "    for (long long i = 2; i < n; i++) {",
            "      fact_[i] = fact_[i - 1] * i;",
            "      inv_[i] = ~fact_[i];",
            "    }",
            "  }",
            "  constexpr T nCr(int n, int r) {",
            "    if (n < r || n < 0 || r < 0) return 0;",
            "    return fact_[n] * inv_[r] * inv_[n - r];",
            "  }",
            "  constexpr T nHr(int n, int r) {",
            "    if (n == 0 and r == 0) return 1;",
            "    if (n <= 0 or r < 0) return 0;",
            "    return nCr(n + r - 1, r);",
            "  }",
            "  constexpr T nPr(int n, int r) { return fact(n) / fact(n - r); }",
            "  constexpr T fact(int n) {",
            "    if (n < 0) return 0;",
            "    return fact_[n];",
            "  }",
            "  constexpr T inv(int n) {",
            "    if (n < 0) return 0;",
            "    return inv_[n];",
            "  }",
            "};"
        ],
        "description": "description for BI_COMB"
    },
    "BIG_INT": {
        "prefix": "BIG_INT",
        "body": [
            "const int base = 1000000000;",
            "const int base_digits = 9;",
            "",
            "struct bigint {",
            "  vector<int> a;",
            "  int sign;",
            "",
            "  bigint() : sign(1) {}",
            "",
            "  bigint(long long v) { *this = v; }",
            "",
            "  bigint(const string &s) { read(s); }",
            "",
            "  void operator=(const bigint &v) {",
            "    sign = v.sign;",
            "    a = v.a;",
            "  }",
            "",
            "  void operator=(long long v) {",
            "    sign = 1;",
            "    if (v < 0) sign = -1, v = -v;",
            "    for (; v > 0; v = v / base) a.push_back(v % base);",
            "  }",
            "",
            "  bigint operator+(const bigint &v) const {",
            "    if (sign == v.sign) {",
            "      bigint res = v;",
            "",
            "      for (int i = 0, carry = 0; i < (int)max(a.size(), v.a.size()) || carry;",
            "           ++i) {",
            "        if (i == (int)res.a.size()) res.a.push_back(0);",
            "        res.a[i] += carry + (i < (int)a.size() ? a[i] : 0);",
            "        carry = res.a[i] >= base;",
            "        if (carry) res.a[i] -= base;",
            "      }",
            "      return res;",
            "    }",
            "    return *this - (-v);",
            "  }",
            "",
            "  bigint operator-(const bigint &v) const {",
            "    if (sign == v.sign) {",
            "      if (abs() >= v.abs()) {",
            "        bigint res = *this;",
            "        for (int i = 0, carry = 0; i < (int)v.a.size() || carry; ++i) {",
            "          res.a[i] -= carry + (i < (int)v.a.size() ? v.a[i] : 0);",
            "          carry = res.a[i] < 0;",
            "          if (carry) res.a[i] += base;",
            "        }",
            "        res.trim();",
            "        return res;",
            "      }",
            "      return -(v - *this);",
            "    }",
            "    return *this + (-v);",
            "  }",
            "",
            "  void operator*=(int v) {",
            "    if (v < 0) sign = -sign, v = -v;",
            "    for (int i = 0, carry = 0; i < (int)a.size() || carry; ++i) {",
            "      if (i == (int)a.size()) a.push_back(0);",
            "      long long cur = a[i] * (long long)v + carry;",
            "      carry = (int)(cur / base);",
            "      a[i] = (int)(cur % base);",
            "      // asm(\"divl %%ecx\" : \"=a\"(carry), \"=d\"(a[i]) : \"A\"(cur), \"c\"(base));",
            "    }",
            "    trim();",
            "  }",
            "",
            "  bigint operator*(int v) const {",
            "    bigint res = *this;",
            "    res *= v;",
            "    return res;",
            "  }",
            "",
            "  friend pair<bigint, bigint> divmod(const bigint &a1, const bigint &b1) {",
            "    int norm = base / (b1.a.back() + 1);",
            "    bigint a = a1.abs() * norm;",
            "    bigint b = b1.abs() * norm;",
            "    bigint q, r;",
            "    q.a.resize(a.a.size());",
            "",
            "    for (int i = a.a.size() - 1; i >= 0; i--) {",
            "      r *= base;",
            "      r += a.a[i];",
            "      int s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];",
            "      int s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];",
            "      int d = ((long long)base * s1 + s2) / b.a.back();",
            "      r -= b * d;",
            "      while (r < 0) r += b, --d;",
            "      q.a[i] = d;",
            "    }",
            "",
            "    q.sign = a1.sign * b1.sign;",
            "    r.sign = a1.sign;",
            "    q.trim();",
            "    r.trim();",
            "    return make_pair(q, r / norm);",
            "  }",
            "",
            "  bigint operator/(const bigint &v) const { return divmod(*this, v).first; }",
            "",
            "  bigint operator%(const bigint &v) const { return divmod(*this, v).second; }",
            "",
            "  void operator/=(int v) {",
            "    if (v < 0) sign = -sign, v = -v;",
            "    for (int i = (int)a.size() - 1, rem = 0; i >= 0; --i) {",
            "      long long cur = a[i] + rem * (long long)base;",
            "      a[i] = (int)(cur / v);",
            "      rem = (int)(cur % v);",
            "    }",
            "    trim();",
            "  }",
            "",
            "  bigint operator/(int v) const {",
            "    bigint res = *this;",
            "    res /= v;",
            "    return res;",
            "  }",
            "",
            "  int operator%(int v) const {",
            "    if (v < 0) v = -v;",
            "    int m = 0;",
            "    for (int i = a.size() - 1; i >= 0; --i)",
            "      m = (a[i] + m * (long long)base) % v;",
            "    return m * sign;",
            "  }",
            "",
            "  void operator+=(const bigint &v) { *this = *this + v; }",
            "  void operator-=(const bigint &v) { *this = *this - v; }",
            "  void operator*=(const bigint &v) { *this = *this * v; }",
            "  void operator/=(const bigint &v) { *this = *this / v; }",
            "",
            "  bool operator<(const bigint &v) const {",
            "    if (sign != v.sign) return sign < v.sign;",
            "    if (a.size() != v.a.size()) return a.size() * sign < v.a.size() * v.sign;",
            "    for (int i = a.size() - 1; i >= 0; i--)",
            "      if (a[i] != v.a[i]) return a[i] * sign < v.a[i] * sign;",
            "    return false;",
            "  }",
            "",
            "  bool operator>(const bigint &v) const { return v < *this; }",
            "  bool operator<=(const bigint &v) const { return !(v < *this); }",
            "  bool operator>=(const bigint &v) const { return !(*this < v); }",
            "  bool operator==(const bigint &v) const {",
            "    return !(*this < v) && !(v < *this);",
            "  }",
            "  bool operator!=(const bigint &v) const { return *this < v || v < *this; }",
            "",
            "  void trim() {",
            "    while (!a.empty() && !a.back()) a.pop_back();",
            "    if (a.empty()) sign = 1;",
            "  }",
            "",
            "  bool isZero() const { return a.empty() || (a.size() == 1 && !a[0]); }",
            "",
            "  bigint operator-() const {",
            "    bigint res = *this;",
            "    res.sign = -sign;",
            "    return res;",
            "  }",
            "",
            "  bigint abs() const {",
            "    bigint res = *this;",
            "    res.sign *= res.sign;",
            "    return res;",
            "  }",
            "",
            "  long long longValue() const {",
            "    long long res = 0;",
            "    for (int i = a.size() - 1; i >= 0; i--) res = res * base + a[i];",
            "    return res * sign;",
            "  }",
            "",
            "  friend bigint gcd(const bigint &a, const bigint &b) {",
            "    return b.isZero() ? a : gcd(b, a % b);",
            "  }",
            "  friend bigint lcm(const bigint &a, const bigint &b) {",
            "    return a / gcd(a, b) * b;",
            "  }",
            "",
            "  void read(const string &s) {",
            "    sign = 1;",
            "    a.clear();",
            "    int pos = 0;",
            "    while (pos < (int)s.size() && (s[pos] == '-' || s[pos] == '+')) {",
            "      if (s[pos] == '-') sign = -sign;",
            "      ++pos;",
            "    }",
            "    for (int i = s.size() - 1; i >= pos; i -= base_digits) {",
            "      int x = 0;",
            "      for (int j = max(pos, i - base_digits + 1); j <= i; j++)",
            "        x = x * 10 + s[j] - '0';",
            "      a.push_back(x);",
            "    }",
            "    trim();",
            "  }",
            "",
            "  friend istream &operator>>(istream &stream, bigint &v) {",
            "    string s;",
            "    stream >> s;",
            "    v.read(s);",
            "    return stream;",
            "  }",
            "",
            "  friend ostream &operator<<(ostream &stream, const bigint &v) {",
            "    if (v.sign == -1) stream << '-';",
            "    stream << (v.a.empty() ? 0 : v.a.back());",
            "    for (int i = (int)v.a.size() - 2; i >= 0; --i)",
            "      stream << setw(base_digits) << setfill('0') << v.a[i];",
            "    return stream;",
            "  }",
            "",
            "  static vector<int> convert_base(const vector<int> &a, int old_digits,",
            "                                  int new_digits) {",
            "    vector<long long> p(max(old_digits, new_digits) + 1);",
            "    p[0] = 1;",
            "    for (int i = 1; i < (int)p.size(); i++) p[i] = p[i - 1] * 10;",
            "    vector<int> res;",
            "    long long cur = 0;",
            "    int cur_digits = 0;",
            "    for (int i = 0; i < (int)a.size(); i++) {",
            "      cur += a[i] * p[cur_digits];",
            "      cur_digits += old_digits;",
            "      while (cur_digits >= new_digits) {",
            "        res.push_back(int(cur % p[new_digits]));",
            "        cur /= p[new_digits];",
            "        cur_digits -= new_digits;",
            "      }",
            "    }",
            "    res.push_back((int)cur);",
            "    while (!res.empty() && !res.back()) res.pop_back();",
            "    return res;",
            "  }",
            "",
            "  typedef vector<long long> vll;",
            "",
            "  static vll karatsubaMultiply(const vll &a, const vll &b) {",
            "    int n = a.size();",
            "    vll res(n + n);",
            "    if (n <= 32) {",
            "      for (int i = 0; i < n; i++)",
            "        for (int j = 0; j < n; j++) res[i + j] += a[i] * b[j];",
            "      return res;",
            "    }",
            "",
            "    int k = n >> 1;",
            "    vll a1(a.begin(), a.begin() + k);",
            "    vll a2(a.begin() + k, a.end());",
            "    vll b1(b.begin(), b.begin() + k);",
            "    vll b2(b.begin() + k, b.end());",
            "",
            "    vll a1b1 = karatsubaMultiply(a1, b1);",
            "    vll a2b2 = karatsubaMultiply(a2, b2);",
            "",
            "    for (int i = 0; i < k; i++) a2[i] += a1[i];",
            "    for (int i = 0; i < k; i++) b2[i] += b1[i];",
            "",
            "    vll r = karatsubaMultiply(a2, b2);",
            "    for (int i = 0; i < (int)a1b1.size(); i++) r[i] -= a1b1[i];",
            "    for (int i = 0; i < (int)a2b2.size(); i++) r[i] -= a2b2[i];",
            "",
            "    for (int i = 0; i < (int)r.size(); i++) res[i + k] += r[i];",
            "    for (int i = 0; i < (int)a1b1.size(); i++) res[i] += a1b1[i];",
            "    for (int i = 0; i < (int)a2b2.size(); i++) res[i + n] += a2b2[i];",
            "    return res;",
            "  }",
            "",
            "  bigint operator*(const bigint &v) const {",
            "    vector<int> a6 = convert_base(this->a, base_digits, 6);",
            "    vector<int> b6 = convert_base(v.a, base_digits, 6);",
            "    vll a(a6.begin(), a6.end());",
            "    vll b(b6.begin(), b6.end());",
            "    while (a.size() < b.size()) a.push_back(0);",
            "    while (b.size() < a.size()) b.push_back(0);",
            "    while (a.size() & (a.size() - 1)) a.push_back(0), b.push_back(0);",
            "    vll c = karatsubaMultiply(a, b);",
            "    bigint res;",
            "    res.sign = sign * v.sign;",
            "    for (int i = 0, carry = 0; i < (int)c.size(); i++) {",
            "      long long cur = c[i] + carry;",
            "      res.a.push_back((int)(cur % 1000000));",
            "      carry = (int)(cur / 1000000);",
            "    }",
            "    res.a = convert_base(res.a, 6, base_digits);",
            "    res.trim();",
            "    return res;",
            "  }",
            "};"
        ],
        "description": "description for BIG_INT"
    },
    "BIPARTITE": {
        "prefix": "BIPARTITE",
        "body": [
            "class Bipartite {",
            "  int N;",
            "  const G &graph;",
            "  UnionFind UF;",
            "",
            " public:",
            "  explicit Bipartite(const G &graph)",
            "      : graph(graph), N(graph.size()), UF(2 * N) {",
            "    build();",
            "  }",
            "",
            "  void build() {",
            "    for (int i = 0; i < N; i++) {",
            "      for (auto &e : graph[i]) {",
            "        int to = (int)e;",
            "        UF.unite(i, to + N);",
            "        UF.unite(i + N, to);",
            "      }",
            "    }",
            "  }",
            "",
            "  bool is_bipartite_v(int v) { return !UF.same(v, v + N); }",
            "",
            "  bool is_bipartite_all() {",
            "    bool flag = true;",
            "    for (int i = 0; i < N; i++)",
            "      if (UF.same(i, i + N)) flag = false;",
            "    return flag;",
            "  }",
            "};"
        ],
        "description": "description for BIBARTITE"
    },
    "BIPARTITE_COLOR": {
        "prefix": "BIPARTITE_COLOR",
        "body": [
            "class BipartiteColor {",
            " private:",
            "  int N;",
            "  UnWeightedGraph G;",
            "  vector<int> color;",
            "  int min_use = 0;",
            "  int max_use = 0;",
            "  bool res;",
            "",
            " public:",
            "  BipartiteColor(const UnWeightedGraph G) : G(G), N(G.size()) {",
            "    res = true;",
            "    min_use = 0;",
            "    max_use = 0;",
            "    color = vector<int>(N, 0);",
            "",
            "    for (int i = 0; i < N; i++) {",
            "      if (color[i] == 0) {",
            "        vector<int> r;",
            "        dfs(i, 1, r);",
            "        int w = 0;",
            "        int b = 0;",
            "        for (auto x : r) color[x] == 1 ? b++ : w++;",
            "        if (b == 0) b++;",
            "        if (w == 0) w++;",
            "        min_use += min(b, w);",
            "        max_use += max(b, w);",
            "      }",
            "    }",
            "  }",
            "",
            "  bool dfs(int v, int c, vector<int> &r) {",
            "    if (color[v] == 0) {",
            "      r.push_back(v);",
            "      color[v] = c;",
            "      for (auto to : G[v])",
            "        if (!dfs(to, -c, r)) return res = false;",
            "      return true;",
            "    }",
            "    return color[v] == c;",
            "  }",
            "",
            "  bool is_bipartite() { return res; }",
            "",
            "  vector<int> get_color() { return color; }",
            "",
            "  pair<int, int> get_min_max_use() { return make_pair(min_use, max_use); }",
            "};"
        ],
        "description": "description for BIPARTITE_COLOR"
    },
    "BIT": {
        "prefix": "BIT",
        "body": [
            "template <typename T>",
            "struct BIT {",
            "  int n;",
            "  vector<T> data;",
            "",
            "  BIT(int n) : n(n), data(n + 1) {}",
            "",
            "  void add(int i, T x) {",
            "    for (i++; i <= n; i += i & -i) data[i] += x;",
            "  }",
            "",
            "  T sum(int i) {",
            "    T x = 0;",
            "    for (i++; i; i -= i & -i) x += data[i];",
            "    return x;",
            "  }",
            "",
            "  // [l, r)",
            "  T sum(int l, int r) { return sum(r - 1) - sum(l - 1); }",
            "};"
        ],
        "description": "description for BIT"
    },
    "COMPERSS": {
        "prefix": "COMPERSS",
        "body": [
            "template <typename T>",
            "vector<T> COMPRESS(vector<T> v) {",
            "  sort(v.begin(), v.end());",
            "  v.erase(unique(v.begin(), v.end()), v.end());",
            "  return v;",
            "}"
        ],
        "description": "description for COMPERSS"
    },
    "CUL_SUM": {
        "prefix": "CUL_SUM",
        "body": [
            "template <typename T>",
            "class CulSum {",
            " private:",
            "  long long N;",
            "  vector<T> a;",
            "  vector<T> aa;",
            "  vector<T> b;",
            "  vector<T> bb;",
            "",
            "  function<T(T, T)> func;",
            "",
            " public:",
            "  /// @param a original array",
            "  CulSum(vector<T> _a) {",
            "    N = _a.size();",
            "    a = _a;",
            "    b = _a;",
            "    reverse(b.begin(), b.end());",
            "    this->aa = vector<T>(N + 1, T{});",
            "    this->bb = vector<T>(N + 1, T{});",
            "    for (int i = 0; i < N; i++) aa[i + 1] = a[i] + aa[i];",
            "    for (int i = 0; i < N; i++) bb[i + 1] = b[i] + bb[i];",
            "  }",
            "",
            "  /// @param a original array",
            "  CulSum(vector<T> _a, function<T(T, T)> func) : func(func) {",
            "    N = _a.size();",
            "    a = _a;",
            "    b = _a;",
            "    reverse(b.begin(), b.end());",
            "    this->aa = vector<T>(N + 1, T{});",
            "    this->bb = vector<T>(N + 1, T{});",
            "    for (int i = 0; i < N; i++) aa[i + 1] = func(a[i], aa[i]);",
            "    for (int i = 0; i < N; i++) bb[i + 1] = func(b[i], bb[i]);",
            "  }",
            "",
            "  /// @brief 0-index original",
            "  /// @param l original close",
            "  /// @param r original open",
            "  T get_sum(int l, int r) { return aa[r] - aa[l]; }",
            "",
            "  /// @brief 0-index original",
            "  /// @param l original close",
            "  /// @param r original open",
            "  T get_sum_reverse(int l, int r) {",
            "    l = N - l;",
            "    r = N - r;",
            "    return bb[l] - bb[r];",
            "  }",
            "",
            "  /// @brief 0-index original",
            "  /// @param k length",
            "  T get_sum_lead_k_len(int k) { return get_sum(0, k); }",
            "",
            "  /// @brief 0-index original",
            "  /// @param k length",
            "  T get_sum_tail_k_len(int k) { return get_sum_reverse(N - k, N); }",
            "",
            "  void show() {",
            "    for (int i = 0; i < N + 1; i++) cout << aa[i] << \" \";",
            "    cout << endl;",
            "  }",
            "",
            "  void show_reverse() {",
            "    for (int i = N; i >= 0; i--) cout << bb[i] << \" \";",
            "    cout << endl;",
            "  }",
            "};"
        ],
        "description": "description for CUL_SUM"
    },
    "CUL_SUM_2D": {
        "prefix": "CUL_SUM_2D",
        "body": [
            "template <class T>",
            "class CulSum2D {",
            " private:",
            "  // original",
            "  int H, W;",
            "",
            "  // original+1",
            "  vector<vector<T>> data;",
            "",
            " public:",
            "  /// @param _H original",
            "  /// @param _W original",
            "  CulSum2D(int _H, int _W) : H(_H), W(_W) { reset(); }",
            "",
            "  void reset() { data = vector<vector<T>>(H + 1, vector<T>(W + 1, T{})); }",
            "",
            "  /// 0-index",
            "  /// @param y original",
            "  /// @param x original",
            "  /// @param d original",
            "  void add(T y, T x, T d) {",
            "    y++;",
            "    x++;",
            "    if (y >= H + 1 || x >= W + 1) return;",
            "    data[y][x] += d;",
            "  }",
            "",
            "  void build() {",
            "    for (int i = 0; i < H; i++) {",
            "      for (int j = 0; j < W; j++) {",
            "        data[i + 1][j + 1] += data[i + 1][j] + data[i][j + 1] - data[i][j];",
            "      }",
            "    }",
            "  }",
            "",
            "  /// 0-index",
            "  /// @param sy original close",
            "  /// @param sx original close",
            "  /// @param ty original open",
            "  /// @param tx original open",
            "  T get(int sy, int sx, int ty, int tx) {",
            "    return data[ty][tx] - data[ty][sx] - data[sy][tx] + data[sy][sx];",
            "  }",
            "};"
        ],
        "description": "description for CUL_SUM_2D"
    },
    "CYCLE_FIND": {
        "prefix": "CYCLE_FIND",
        "body": [
            "template <class G>",
            "class CycleFind {",
            " private:",
            "  int V;",
            "  int key_v;",
            "  vector<bool> going;",
            "  vector<bool> backing;",
            "  vector<int> cycle_path;",
            "  stack<int> history;",
            "  const G &graph;",
            "",
            " public:",
            "  CycleFind(const G &_graph) : graph(_graph), key_v(-1) {",
            "    V = graph.size();",
            "    going = vector<bool>(V, false);",
            "    backing = vector<bool>(V, false);",
            "    build();",
            "  }",
            "",
            "  void dfs(int v, int p) {",
            "    going[v] = true;",
            "    history.push(v);",
            "    for (auto e : graph[v]) {",
            "      int to = (int)e;",
            "      if (to == p) continue;",
            "      if (backing[to]) continue;",
            "      if (going[to] && !backing[to]) {",
            "        key_v = to;",
            "        return;",
            "      }",
            "      dfs(to, v);",
            "      if (key_v != -1) return;",
            "    }",
            "    history.pop();",
            "    backing[v] = true;",
            "  }",
            "",
            "  bool has_cycle() { return key_v != -1; }",
            "",
            "  vector<int> get_cycle_path() const { return cycle_path; }",
            "",
            "  void build() {",
            "    for (int i = 0; i < V; i++)",
            "      if (!going[i] && key_v == -1) dfs(i, -1);",
            "    if (has_cycle()) {",
            "      cycle_path = vector<int>();",
            "      while (!history.empty()) {",
            "        auto v = history.top();",
            "        history.pop();",
            "        cycle_path.push_back(v);",
            "        if (v == key_v) break;",
            "      }",
            "      reverse(cycle_path.begin(), cycle_path.end());",
            "    }",
            "  }",
            "};"
        ],
        "description": "description for CYCLE_FIND"
    },
    "DIJKSTRA": {
        "prefix": "DIJKSTRA",
        "body": [
            "template <typename T>",
            "class Dijkstra {",
            "  using Pr = pair<T, int>;",
            "",
            " private:",
            "  int V;",
            "  const WeightedGraph<T> &graph;",
            "  const T INF = numeric_limits<T>::max();",
            "  vector<T> dist;",
            "  vector<int> prev;",
            "",
            " public:",
            "  Dijkstra(const WeightedGraph<T> &graph, int s) : graph(graph) {",
            "    V = graph.size();",
            "    dijkstra(s);",
            "  }",
            "",
            "  void dijkstra(int s) {",
            "    priority_queue<Pr, vector<Pr>, greater<>> Q;",
            "    dist = vector<T>(V, INF);",
            "    prev = vector<int>(V, -1);",
            "    Q.push(make_pair(0, s));",
            "    dist[s] = 0;",
            "    while (!Q.empty()) {",
            "      auto p = Q.top();",
            "      Q.pop();",
            "      T now = p.first;",
            "      int v = p.second;",
            "      if (dist[v] < now) continue;",
            "      for (auto e : graph[v]) {",
            "        int to = e.to;",
            "        T cost = e.cost;",
            "        if (dist[to] > dist[v] + cost) {",
            "          dist[to] = dist[v] + cost;",
            "          prev[to] = v;",
            "          Q.push(make_pair(dist[to], to));",
            "        }",
            "      }",
            "    }",
            "  }",
            "",
            "  vector<T> get_dist() const { return dist; }",
            "",
            "  vector<int> get_prev() const { return prev; }",
            "};"
        ],
        "description": "description for DIJKSTRA"
    },
    "DINIC": {
        "prefix": "DINIC",
        "body": [
            "template <class FT>",
            "struct Dinic {",
            "  const FT INF;",
            "",
            "  struct edge {",
            "    int to;",
            "    FT cap;",
            "    int rev;",
            "    bool is_rev;",
            "  };",
            "",
            "  vector<vector<edge>> graph;",
            "  vector<int> min_cost, iter;",
            "",
            "  Dinic(int V) : INF(numeric_limits<FT>::max()), graph(V) {}",
            "",
            "  void add_edge(int from, int to, FT cap, int idx = -1) {",
            "    graph[from].emplace_back((edge){to, cap, (int)graph[to].size(), false});",
            "    graph[to].emplace_back((edge){from, 0, (int)graph[from].size() - 1, true});",
            "  }",
            "",
            "  // if true then still exist add path",
            "  bool bfs(int s, int t) {",
            "    min_cost.assign(graph.size(), -1);",
            "    min_cost[s] = 0;",
            "    queue<int> Q;",
            "    Q.push(s);",
            "    while (!Q.empty() and min_cost[t] == -1) {",
            "      int v = Q.front();",
            "      Q.pop();",
            "      for (auto &e : graph[v]) {",
            "        if (e.cap > 0 and min_cost[e.to] == -1) {",
            "          min_cost[e.to] = min_cost[v] + 1;",
            "          Q.push(e.to);",
            "        }",
            "      }",
            "    }",
            "    return min_cost[t] != -1;",
            "  }",
            "",
            "  FT dfs(const int v, const int t, FT flow) {",
            "    if (v == t) return flow;",
            "    for (int &i = iter[v]; i < graph[v].size(); i++) {",
            "      edge &e = graph[v][i];",
            "      if (e.cap > 0 and min_cost[v] < min_cost[e.to]) {",
            "        FT d = dfs(e.to, t, min(flow, e.cap));",
            "        if (d > 0) {",
            "          e.cap -= d;",
            "          graph[e.to][e.rev].cap += d;",
            "          return d;",
            "        }",
            "      }",
            "    }",
            "    return 0;",
            "  }",
            "",
            "  FT max_flow(int s, int t) {",
            "    FT flow = 0;",
            "    while (bfs(s, t)) {",
            "      iter.assign(graph.size(), 0);",
            "      FT f = 0;",
            "      while ((f = dfs(s, t, INF)) > 0) flow += f;",
            "    }",
            "    return flow;",
            "  }",
            "",
            "  void println() {",
            "    for (int i = 0; i < graph.size(); i++) {",
            "      for (auto &e : graph[i]) {",
            "        if (e.isrev) continue;",
            "        auto &rev_e = graph[e.to][e.rev];",
            "        cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\"",
            "             << e.cap + rev_e.cap << \")\" << endl;",
            "      }",
            "    }",
            "  }",
            "};"
        ],
        "description": "description for DINIC"
    },
    "DOUBLING": {
        "prefix": "DOUBLING",
        "body": [
            "struct Doubling {",
            "  const long long LOG;",
            "  const int N;",
            "  vector<vector<int>> nexted;",
            "",
            "  Doubling(int N, long long log = 60) : N(N), LOG(log) {",
            "    nexted.assign(LOG + 1, vector<int>(N + 1, -1));",
            "  }",
            "",
            "  inline void set_init_next(const int v, const int x) { nexted[0][v] = x; }",
            "",
            "  void build() {",
            "    for (int k = 0; k < LOG; k++) {",
            "      for (int v = 0; v < N; v++) {",
            "        if (nexted[k][v] == -1)",
            "          nexted[k + 1][v] = -1;",
            "        else",
            "          nexted[k + 1][v] = nexted[k][nexted[k][v]];",
            "      }",
            "    }",
            "  }",
            "",
            "  inline int query(int v, long long p) {",
            "    for (long long i = LOG; i >= 0; i--) {",
            "      if (v < 0) return -1;",
            "      if (p & (1LL << i)) {",
            "        v = nexted[i][v];",
            "      }",
            "    }",
            "    return v;",
            "  }",
            "};"
        ],
        "description": "description for DOUBLING"
    },
    "IMOS": {
        "prefix": "IMOS",
        "body": [
            "template <class T>",
            "class Imos {",
            " private:",
            "  // original",
            "  int N;",
            "",
            "  // original+1",
            "  vector<T> data;",
            "",
            " public:",
            "  /// @param _N original",
            "  Imos(int _N) : N(_N) { reset(); }",
            "",
            "  /// @details to set this imos",
            "  void reset() { data = vector<T>(N + 1, T{}); }",
            "",
            "  /// @details 0-index [l, r]",
            "  /// @param l original close",
            "  /// @param r original close",
            "  void add(int l, int r, T d) {",
            "    data[l] += d;",
            "    data[r + 1] -= d;",
            "  }",
            "",
            "  /// @details before to use",
            "  void build() {",
            "    for (int i = 0; i < N; i++) data[i + 1] += data[i];",
            "  }",
            "",
            "  /// @details 0-index",
            "  /// @param pos original",
            "  T get(T pos) { return data[pos]; }",
            "",
            "  T &operator[](int n) { return data[n]; }",
            "",
            "  /// @details to_show now",
            "  void show() {",
            "    for (int i = 0; i < N + 1; i++) {",
            "      printf(\"%5d \", data[i]);",
            "    }",
            "    printf(\"\\n\");",
            "  }",
            "};"
        ],
        "description": "description for IMOS"
    },
    "IMOS_2D": {
        "prefix": "IMOS_2D",
        "body": [
            "template <class T>",
            "class Imos2D {",
            " private:",
            "  // original",
            "  int H, W;",
            "",
            "  // original+1",
            "  vector<vector<T>> data;",
            "",
            "  /// @details You can't use.",
            "  void _add(T y, T x, T d) {",
            "    if (y >= H + 1 || x >= W + 1) return;",
            "    data[y][x] += d;",
            "  }",
            "",
            " public:",
            "  /// @param _H original",
            "  /// @param _W original",
            "  Imos2D(int _H, int _W) : H(_H), W(_W) { reset(); }",
            "",
            "  /// @details to set this imos",
            "  void reset() { data = vector<vector<T>>(H + 1, vector<T>(W + 1, T{})); }",
            "",
            "  /// @details 0-index [(sy, sx) - (ty, tx)]",
            "  /// @param sy original close",
            "  /// @param sx original close",
            "  /// @param ty original close",
            "  /// @param tx original close",
            "  void add_two(T sy, T sx, T ty, T tx, T d) {",
            "    _add(sy, sx, d);",
            "    _add(sy, tx + 1, -d);",
            "    _add(ty + 1, sx, -d);",
            "    _add(ty + 1, tx + 1, d);",
            "  }",
            "",
            "  /// @details before to use",
            "  void build() {",
            "    for (int i = 0; i < H + 1; i++) {",
            "      for (int j = 0; j < W; j++) {",
            "        data[i][j + 1] += data[i][j];",
            "      }",
            "    }",
            "    for (int i = 0; i < W + 1; i++) {",
            "      for (int j = 0; j < H; j++) {",
            "        data[j + 1][i] += data[j][i];",
            "      }",
            "    }",
            "  }",
            "",
            "  /// @details 0-index",
            "  /// @param y original",
            "  /// @param x original",
            "  T get(T y, T x) { return data[y][x]; }",
            "  /// @details to_show now",
            "  void show() {",
            "    for (int i = 0; i < H + 1; i++) {",
            "      for (int j = 0; j < W + 1; j++) {",
            "        printf(\"%4d \", data[i][j]);",
            "      }",
            "      printf(\"\\n\");",
            "    }",
            "  }",
            "};"
        ],
        "description": "description for IMOS_2D"
    },
    "KMP": {
        "prefix": "KMP",
        "body": [
            "class KMP {",
            " private:",
            "  int len;",
            "",
            "  /// @details pat 検索したいパターン",
            "  string pat;",
            "",
            "  // table to use kmp",
            "  vector<int> table;",
            "",
            " public:",
            "  /// @param _pat 検索したいパターン",
            "  KMP(const string _pat) {",
            "    len = _pat.size();",
            "    pat = _pat;",
            "    table = vector<int>(len + 1);",
            "    make_table();",
            "  }",
            "",
            "  /// @details S[0, i)の文字列の 接頭辞と接尾辞の最大の共通の長さ(min(i-1))",
            "  void make_table() {",
            "    table[0] = -1;",
            "    int j = -1;",
            "    for (int i = 0; i < len; i++) {",
            "      while (j >= 0 && pat[i] != pat[j]) j = table[j];",
            "      table[i + 1] = ++j;",
            "    }",
            "  }",
            "",
            "  /// @param S patが含まれる文字列",
            "  /// @details pstがSに含まれる位置のvectorを返す",
            "  vector<int> kmp(const string &S) {",
            "    vector<int> ret;",
            "    int m = 0, i = 0, n = S.size();",
            "    while (m + i < n) {",
            "      if (pat[i] == S[m + i]) {",
            "        if (++i == len) {",
            "          ret.push_back(m);",
            "          m = m + i - table[i];",
            "          i = table[i];",
            "        }",
            "      } else {",
            "        m = m + i - table[i];",
            "        if (i > 0) i = table[i];",
            "      }",
            "    }",
            "    return ret;",
            "  }",
            "",
            "  /// @param S patが含まれる文字列",
            "  /// @details pstがSに含まれる最初の位置を返す -1は含まれない",
            "  int contain(const string &S) {",
            "    int m = 0, i = 0, n = S.size();",
            "    while (m + i < n) {",
            "      if (pat[i] == S[m + i]) {",
            "        if (++i == len) {",
            "          return m;",
            "        }",
            "      } else {",
            "        m = m + i - table[i];",
            "        if (i > 0) i = table[i];",
            "      }",
            "    }",
            "    return -1;",
            "  }",
            "",
            "  void show_table() {",
            "    printf(\"i:\");",
            "    for (int i = 0; i <= len; i++) printf(\"%3d \", i);",
            "    printf(\"\\n\");",
            "    printf(\"R:\");",
            "    for (int i = 0; i <= len; i++) printf(\"%3d \", table[i]);",
            "    printf(\"\\n\");",
            "  }",
            "};"
        ],
        "description": "description for KMP"
    },
    "LINT": {
        "prefix": "LINT",
        "body": [
            "typedef __int128 Lint;",
            "",
            "Lint toLint(const string s) {",
            "  Lint ret = 0;",
            "  for (int i = 0; i < s.length(); i++)",
            "    if ('0' <= s[i] && s[i] <= '9') ret = 10 * ret + s[i] - '0';",
            "  return ret;",
            "}",
            "",
            "ostream &operator<<(ostream &dest, __int128_t value) {",
            "  ostream::sentry s(dest);",
            "  if (s) {",
            "    __uint128_t tmp = value < 0 ? -value : value;",
            "    char buffer[128];",
            "    char *d = std::end(buffer);",
            "    do {",
            "      --d;",
            "      *d = \"0123456789\"[tmp % 10];",
            "      tmp /= 10;",
            "    } while (tmp != 0);",
            "    if (value < 0) {",
            "      --d;",
            "      *d = '-';",
            "    }",
            "    int len = std::end(buffer) - d;",
            "    if (dest.rdbuf()->sputn(d, len) != len) {",
            "      dest.setstate(ios_base::badbit);",
            "    }",
            "  }",
            "  return dest;",
            "}",
            "",
            "istream &operator>>(istream &in, Lint &d) {",
            "  string s;",
            "  cin >> s;",
            "  Lint tmp = 0;",
            "  for (int i = 0; i < s.length(); i++)",
            "    if ('0' <= s[i] && s[i] <= '9') tmp = 10 * tmp + s[i] - '0';",
            "  d = tmp;",
            "  return in;",
            "}"
        ],
        "description": "description for LINT"
    },
    "LONGEST_COMMON_PREFIX_ARRAY": {
        "prefix": "LONGEST_COMMON_PREFIX_ARRAY",
        "body": [
            "class Longest_Common_Prefix_Array {",
            " private:",
            "  int n;",
            "  const Suffix_Array &suffixArray;",
            "",
            "  /// @param LCP[i] = SAでi,i+1番目に小さい文字列の最長共通接頭辞",
            "  vector<int> LCP;",
            "",
            "  /// @param rank[i] = S[i:]の文字列はSAで何番目に小さいか",
            "  vector<int> rank;",
            "",
            "  SparseTable<int> sparseTable;",
            "",
            " public:",
            "  Longest_Common_Prefix_Array(const Suffix_Array &suffixArray)",
            "      : suffixArray(suffixArray) {",
            "    n = suffixArray.get_S().size();",
            "    LCP = vector<int>(n + 1);",
            "    rank = vector<int>(n + 1);",
            "    construct();",
            "  }",
            "",
            "  void construct() {",
            "    const vector<int> &SA = suffixArray.get_SA();",
            "    const string S = suffixArray.get_S();",
            "    for (int i = 0; i <= n; i++) rank[SA[i]] = i;",
            "",
            "    // S[i:]と S[i:]より文字列順で1小さい文字列とのlcp長",
            "    int h = 0;",
            "",
            "    // 0番目に小さい文字列は\"\"より、0",
            "    LCP[0] = 0;",
            "",
            "    // Sの先頭|S[i:]|=nから",
            "    for (int i = 0; i < n; i++) {",
            "      // S[i:]より1小さい文字列のS上の位置",
            "      int j = SA[rank[i] - 1];",
            "",
            "      if (h > 0) h--;",
            "",
            "      //後ろが一致してるだけ増やす",
            "      while (j + h < n && i + h < n) {",
            "        if (S[j + h] != S[i + h]) break;",
            "        h++;",
            "      }",
            "",
            "      LCP[rank[i] - 1] = h;",
            "    }",
            "",
            "    sparseTable = SparseTable<int>(LCP);",
            "  }",
            "",
            "  vector<int> get_LCP() { return LCP; }",
            "",
            "  int operator[](int k) const { return LCP[k]; }",
            "",
            "  /// @param i original S[i:]",
            "  /// @param j original S[j:]",
            "  int common(int i, int j) {",
            "    if (i == j)",
            "      return n - i;",
            "    else {",
            "      int l = rank[i];",
            "      int r = rank[j];",
            "      if (l > r) swap(l, r);",
            "      return LCP[sparseTable.get(l, r)];",
            "    }",
            "  }",
            "",
            "  void show() {",
            "    printf(\"alphabetical order\\n\");",
            "    printf(\"i :\");",
            "    for (int i = 0; i <= n; i++) printf(\"%3d\", i);",
            "    printf(\"\\n\");",
            "    printf(\"LC:\");",
            "    for (int i = 0; i <= n; i++) printf(\"%3d\", LCP[i]);",
            "    printf(\"\\n\\n\");",
            "  }",
            "",
            "  void all_show() {",
            "    const vector<int> &SA = suffixArray.get_SA();",
            "    printf(\"alphabetical order\\n\");",
            "    printf(\"i :\");",
            "    for (int i = 0; i <= n; i++) printf(\"%3d\", i);",
            "    printf(\"\\n\");",
            "    printf(\"SA:\");",
            "    for (int i = 0; i <= n; i++) printf(\"%3d\", SA[i]);",
            "    printf(\"\\n\");",
            "    printf(\"LC:\");",
            "    for (int i = 0; i <= n; i++) printf(\"%3d\", LCP[i]);",
            "    printf(\"\\n\");",
            "    printf(\"RK:\");",
            "    for (int i = 0; i <= n; i++) printf(\"%3d\", rank[i]);",
            "    printf(\"\\n\\n\");",
            "  }",
            "};"
        ],
        "description": "description for LONGEST_COMMON_PREFIX_ARRAY"
    },
    "LOWEST_COMMON_ANCESTOR": {
        "prefix": "LOWEST_COMMON_ANCESTOR",
        "body": [
            "template <typename T>",
            "class LowestCommonAncestor {",
            " private:",
            "  const long long LOG;",
            "  const int N;",
            "",
            "  const WeightedGraph<T> &graph;",
            "  vector<int> depth;",
            "  vector<T> dist;",
            "  vector<vector<int>> nexted;",
            "",
            " public:",
            "  LowestCommonAncestor(const WeightedGraph<T> &graph, const long long LOG = 60)",
            "      : graph(graph),",
            "        LOG(LOG),",
            "        N(graph.size()),",
            "        depth(N, -1),",
            "        dist(N, numeric_limits<T>::max()) {",
            "    nexted.assign(LOG + 1, vector<int>(N, -1));",
            "  }",
            "",
            "  void dfs(int v, int p, int d, long long sum) {",
            "    depth[v] = d;",
            "    dist[v] = sum;",
            "    nexted[0][v] = p;",
            "    for (auto e : graph[v]) {",
            "      int to = e.to;",
            "      long long cost = e.cost;",
            "      if (to != p) {",
            "        dfs(to, v, d + 1, sum + cost);",
            "      }",
            "    }",
            "  }",
            "",
            "  void build(int s) {",
            "    dfs(s, -1, 0, 0);",
            "    for (int k = 0; k < LOG; k++) {",
            "      for (int v = 0; v < N; v++) {",
            "        if (nexted[k][v] == -1)",
            "          nexted[k + 1][v] = -1;",
            "        else",
            "          nexted[k + 1][v] = nexted[k][nexted[k][v]];",
            "      }",
            "    }",
            "  }",
            "",
            "  int lca(int u, int v) {",
            "    if (depth[u] > depth[v]) swap(u, v);",
            "    for (long long i = LOG - 1; i >= 0; i--) {",
            "      if ((depth[v] - depth[u]) & (1LL << i)) {",
            "        v = nexted[i][v];",
            "      }",
            "    }",
            "    if (u == v) return u;",
            "    for (long long i = LOG - 1; i >= 0; i--) {",
            "      if (nexted[i][u] != nexted[i][v]) {",
            "        u = nexted[i][u];",
            "        v = nexted[i][v];",
            "      }",
            "    }",
            "    return nexted[0][u];",
            "  }",
            "",
            "  int parent_d(int v, long long d) {",
            "    for (long long i = LOG - 1; i >= 0; i--) {",
            "      if (d & (1LL << i)) {",
            "        v = nexted[i][v];",
            "      }",
            "    }",
            "    return v;",
            "  }",
            "",
            "  T get_distance(int u, int v) {",
            "    T sum = dist[u] + dist[v] - 2 * dist[lca(u, v)];",
            "    return sum;",
            "  }",
            "};"
        ],
        "description": "description for LOWEST_COMMON_ANCESTOR"
    },
    "LOWLINK": {
        "prefix": "LOWLINK",
        "body": [
            "template <typename G>",
            "struct LowLink {",
            "  const G &g;",
            "",
            "  int k;",
            "  vector<int> used, ord, low;",
            "",
            "  vector<int> arts;",
            "  vector<int> articulations;",
            "  vector<pair<int, int>> bridges;",
            "",
            "  LowLink(const G &g) : g(g) {}",
            "",
            "  void dfs(int v, int p) {",
            "    used[v] = 1;",
            "    ord[v] = low[v] = k++;",
            "    bool is_art = false;",
            "    int art_cnt = 0;",
            "    int cnt = 0;",
            "    for (auto &to : g[v]) {",
            "      if (!used[to]) {",
            "        cnt++;",
            "        dfs(to, v);",
            "        low[v] = min(low[v], low[to]);",
            "        is_art |= ~p && ord[v] <= low[to];",
            "        art_cnt += ~p && ord[v] <= low[to];",
            "        if (ord[v] < low[to])",
            "          bridges.emplace_back(min(v, (int)to), max(v, (int)to));",
            "      } else if (to != p) {",
            "        low[v] = min(low[v], ord[to]);",
            "      }",
            "    }",
            "    is_art |= p == -1 and cnt > 1;",
            "    art_cnt += (p == -1 and cnt > 1);",
            "    if (is_art) articulations.push_back(v);",
            "    arts[v] = art_cnt + 1;",
            "  }",
            "",
            "  void build() {",
            "    int n = g.size();",
            "    arts.assign(n, 0);",
            "    used.assign(n, 0);",
            "    ord.assign(n, 0);",
            "    low.assign(n, 0);",
            "    k = 0;",
            "    for (int i = 0; i < n; i++) {",
            "      if (!used[i]) {",
            "        dfs(i, -1);",
            "      }",
            "    }",
            "  }",
            "};"
        ],
        "description": "description for LOWLINK"
    },
    "MAPPING": {
        "prefix": "MAPPING",
        "body": [
            "template <typename T>",
            "pair<map<T, int>, map<int, T>> MAPPING(const vector<T> v) {",
            "  map<T, int> zip;",
            "  map<int, T> unzip;",
            "  for (int i = 0; i < v.size(); i++) zip[v[i]] = i;",
            "  for (int i = 0; i < v.size(); i++) unzip[i] = v[i];",
            "  return make_pair(zip, unzip);",
            "}"
        ],
        "description": "description for MAPPING"
    },
    "MATH": {
        "prefix": "MATH",
        "body": [
            "template <typename T>",
            "istream &operator>>(istream &in, vector<T> &v) {",
            "  rep(i, v.size()) in >> v[i];",
            "  return in;",
            "}",
            "template <typename T1, typename T2>",
            "bool chmin(T1 &x, T2 y) {",
            "  if (x > y) {",
            "    x = y;",
            "    return true;",
            "  } else {",
            "    return false;",
            "  }",
            "}",
            "template <typename T1, typename T2>",
            "bool chmax(T1 &x, T2 y) {",
            "  if (x < y) {",
            "    x = y;",
            "    return true;",
            "  } else {",
            "    return false;",
            "  }",
            "}",
            "template <typename T1, typename T2>",
            "T1 ce(T1 x, T2 y) {",
            "  return (x + y - 1) / y;",
            "}",
            "",
            "//------------------------------------------",
            "//------------------------------------------",
            "template <typename T>",
            "inline bool BETWEEN(const T aim, const T min, const T max) {",
            "  return min <= aim && aim <= max;",
            "}",
            "",
            "template <typename T1, typename T2>",
            "inline bool IS_OUT(const T1 toY, const T1 toX, const T2 H, const T2 W) {",
            "  return (toY < 0 || toY >= H || toX < 0 || toX >= W);",
            "}",
            "",
            "template <class T>",
            "inline T SQR(const T x) {",
            "  return x * x;",
            "}",
            "",
            "template <class T1, class T2>",
            "inline T1 POW(const T1 x, const T2 y) {",
            "  if (!y)",
            "    return 1;",
            "  else if ((y & 1) == 0) {",
            "    return SQR(POW(x, y >> 1));",
            "  } else",
            "    return POW(x, y ^ 1) * x;",
            "}",
            "",
            "template <typename T>",
            "constexpr T ABS(T x) {",
            "  return x < 0 ? -x : x;",
            "}",
            "",
            "template <typename T>",
            "constexpr bool ODD(T x) {",
            "  return x % 2 != 0;",
            "}",
            "",
            "template <typename T>",
            "constexpr bool EVEN(T x) {",
            "  return x % 2 == 0;",
            "}",
            "",
            "template <class T>",
            "inline T GCD(const T x, const T y) {",
            "  if (x < 0) return GCD(-x, y);",
            "  if (y < 0) return GCD(x, -y);",
            "  return (!y) ? x : GCD(y, x % y);",
            "}",
            "",
            "template <class T>",
            "inline T LCM(const T x, const T y) {",
            "  if (x < 0) return LCM(-x, y);",
            "  if (y < 0) return LCM(x, -y);",
            "  return x * (y / GCD(x, y));",
            "}",
            "",
            "// ax + by = gcd(a, b)",
            "template <class T>",
            "inline T EXTGCD(const T a, const T b, T &x, T &y) {",
            "  if (a < 0) {",
            "    T d = EXTGCD(-a, b, x, y);",
            "    x = -x;",
            "    return d;",
            "  }",
            "  if (b < 0) {",
            "    T d = EXTGCD(a, -b, x, y);",
            "    y = -y;",
            "    return d;",
            "  }",
            "  if (!b) {",
            "    x = 1;",
            "    y = 0;",
            "    return a;",
            "  } else {",
            "    T d = EXTGCD(b, a % b, x, y);",
            "    T t = x;",
            "    x = y;",
            "    y = t - (a / b) * y;",
            "    return d;",
            "  }",
            "}",
            "",
            "// gce(a, m) = 1",
            "template <class T>",
            "inline T INV_MOD(const T a, const T m) {",
            "  T x, y;",
            "  EXTGCD(a, m, x, y);",
            "  return (x + m) % m;",
            "}"
        ],
        "description": "description for MATH"
    },
    "MATRIX": {
        "prefix": "MATRIX",
        "body": [
            "template <class T>",
            "using Matrix = vector<vector<T>>;",
            "",
            "template <class T>",
            "Matrix<T> mat_add(const Matrix<T> A, const Matrix<T> B) {",
            "  int m = A.size();",
            "  int n = B[0].size();",
            "  Matrix<T> C(m, vector<T>(n));",
            "  for (int i = 0; i < m; i++) {",
            "    for (int j = 0; j < n; j++) {",
            "      C[i][j] = A[i][j] + B[i][j];",
            "    }",
            "  }",
            "  return C;",
            "}",
            "",
            "template <class T>",
            "Matrix<T> mat_sub(const Matrix<T> A, const Matrix<T> B) {",
            "  int m = A.size();",
            "  int n = B[0].size();",
            "  Matrix<T> C(m, vector<T>(n));",
            "  for (int i = 0; i < m; i++) {",
            "    for (int j = 0; j < n; j++) {",
            "      C[i][j] = A[i][j] - B[i][j];",
            "    }",
            "  }",
            "  return C;",
            "}",
            "",
            "template <class T>",
            "Matrix<T> mat_mul(const Matrix<T> A, const Matrix<T> B) {",
            "  int m = A.size();",
            "  int l = B.size();",
            "  int n = B[0].size();",
            "  Matrix<T> C(m, vector<T>(n));",
            "  for (int i = 0; i < m; i++) {",
            "    for (int j = 0; j < n; j++) {",
            "      for (int k = 0; k < l; k++) {",
            "        C[i][j] += A[i][k] * B[k][j];",
            "      }",
            "    }",
            "  }",
            "  return C;",
            "}",
            "",
            "template <class T>",
            "Matrix<T> mat_pow(Matrix<T> A, LL p) {",
            "  Matrix<T> ret(A.size(), vector<T>(A.size(), 0));",
            "  for (int i = 0; i < A.size(); i++) ret[i][i] = 1;",
            "  while (p > 0) {",
            "    if (p & 1) ret = mat_mul(ret, A);",
            "    A = mat_mul(A, A);",
            "    p >>= 1;",
            "  }",
            "  return ret;",
            "}"
        ],
        "description": "description for MATRIX"
    },
    "MOD_INT": {
        "prefix": "MOD_INT",
        "body": [
            "template <int_fast64_t Modulas = 1000000007ul>",
            "class ModInt {",
            "  using u64 = int_fast64_t;",
            "",
            " public:",
            "  u64 x;",
            "",
            "  constexpr ModInt() : x(0) {}",
            "  constexpr ModInt(int_fast64_t v) : x((v % Modulas + Modulas) % Modulas) {}",
            "  constexpr ModInt operator+(const ModInt rhs) const noexcept {",
            "    return ModInt(*this) += rhs;",
            "  }",
            "  constexpr ModInt operator-(const ModInt rhs) const noexcept {",
            "    return ModInt(*this) -= rhs;",
            "  }",
            "  constexpr ModInt operator*(const ModInt rhs) const noexcept {",
            "    return ModInt(*this) *= rhs;",
            "  }",
            "  constexpr ModInt operator/(const ModInt rhs) const noexcept {",
            "    return ModInt(*this) /= rhs;",
            "  }",
            "  constexpr ModInt operator/(const long long rhs) const noexcept {",
            "    return ModInt(*this) /= rhs;",
            "  }",
            "  constexpr ModInt operator+=(const ModInt rhs) noexcept {",
            "    x += rhs.x;",
            "    if (x >= Modulas) x -= Modulas;",
            "    return *this;",
            "  }",
            "  constexpr ModInt operator+=(const long long rhs) noexcept {",
            "    auto hs = ModInt<Modulas>(rhs);",
            "    (*this) += hs;",
            "    return *this;",
            "  }",
            "  constexpr ModInt operator-=(const ModInt rhs) noexcept {",
            "    if (x < rhs.x) x += Modulas;",
            "    x -= rhs.x;",
            "    return *this;",
            "  }",
            "  constexpr ModInt operator-=(const long long rhs) noexcept {",
            "    auto hs = ModInt<Modulas>(rhs);",
            "    (*this) -= hs;",
            "    return *this;",
            "  }",
            "  constexpr ModInt operator*=(const ModInt rhs) noexcept {",
            "    x = x * rhs.x % Modulas;",
            "    return *this;",
            "  }",
            "  constexpr ModInt operator*=(const long long rhs) noexcept {",
            "    auto hs = ModInt<Modulas>(rhs);",
            "    (*this) *= hs;",
            "    return *this;",
            "  }",
            "  constexpr ModInt &operator/=(ModInt rhs) noexcept {",
            "    u64 exp = Modulas - 2;",
            "    while (exp > 0) {",
            "      if (exp & 1ul) *this *= rhs;",
            "      rhs *= rhs;",
            "      exp >>= 1ul;",
            "    }",
            "    return *this;",
            "  }",
            "  constexpr ModInt &operator/=(long long rhs) noexcept {",
            "    auto hs = ModInt<Modulas>(rhs);",
            "    (*this) /= hs;",
            "    return *this;",
            "  }",
            "",
            "  constexpr ModInt &operator++() noexcept {",
            "    x++;",
            "    if (x >= Modulas) x -= Modulas;",
            "    return *this;",
            "  }",
            "  constexpr ModInt &operator--() noexcept {",
            "    if (x == 0) x += Modulas;",
            "    x--;",
            "    return *this;",
            "  }",
            "  constexpr bool operator<(const ModInt rhs) const noexcept {",
            "    return x < rhs.x;",
            "  }",
            "  constexpr bool operator==(const ModInt rhs) const noexcept {",
            "    return this->x == rhs.x;",
            "  }",
            "  constexpr bool operator!=(const ModInt rhs) const noexcept {",
            "    return !(*this == rhs);",
            "  }",
            "  friend istream &operator>>(istream &in, ModInt &m) {",
            "    in >> m.x;",
            "    if (m.x < 0) m.x += Modulas;",
            "    m.x %= Modulas;",
            "    return in;",
            "  }",
            "  friend ostream &operator<<(ostream &out, const ModInt &p) {",
            "    out << p.x;",
            "    return out;",
            "  }",
            "  constexpr ModInt pow(u64 p) const {",
            "    ModInt ret(1);",
            "    ModInt mul(x);",
            "    while (p > 0) {",
            "      if (p & 1ul) ret *= mul;",
            "      mul *= mul;",
            "      p >>= 1ul;",
            "    }",
            "    return ret;",
            "  }",
            "  constexpr ModInt operator~() const noexcept {",
            "    u64 exp = Modulas - 2;",
            "    return pow(exp);",
            "  }",
            "",
            "  constexpr static ModInt arith_sum(ModInt<Modulas> a, ModInt<Modulas> d,",
            "                                    ModInt<Modulas> n) noexcept {",
            "    return (a * ModInt<Modulas>(2) + (n - 1) * d) * n / ModInt<Modulas>(2);",
            "  }",
            "};"
        ],
        "description": "description for MOD_INT"
    },
    "PERMUTATION": {
        "prefix": "PERMUTATION",
        "body": [
            "template <class Iter>",
            "bool next_partial_permutation(Iter first, Iter middle, Iter last) {",
            "  reverse(middle, last);",
            "  return next_permutation(first, last);",
            "}",
            "",
            "template <class Iter>",
            "bool next_combination(Iter first1, Iter last1, Iter first2, Iter last2) {",
            "  if ((first1 == last1) || (first2 == last2)) {",
            "    return false;",
            "  }",
            "  Iter m1 = last1;",
            "  Iter m2 = last2;",
            "  --m2;",
            "  while (--m1 != first1 && !(*m1 < *m2)) {",
            "  }",
            "  bool result = (m1 == first1) && !(*first1 < *m2);",
            "  if (!result) {",
            "    while (first2 != m2 && !(*m1 < *first2)) {",
            "      ++first2;",
            "    }",
            "    first1 = m1;",
            "    std::iter_swap(first1, first2);",
            "    ++first1;",
            "    ++first2;",
            "  }",
            "  if ((first1 != last1) && (first2 != last2)) {",
            "    m1 = last1;",
            "    m2 = first2;",
            "    while ((m1 != first1) && (m2 != last2)) {",
            "      std::iter_swap(--m1, m2);",
            "      ++m2;",
            "    }",
            "    std::reverse(first1, m1);",
            "    std::reverse(first1, last1);",
            "    std::reverse(m2, last2);",
            "    std::reverse(first2, last2);",
            "  }",
            "  return !result;",
            "}"
        ],
        "description": "description for PERMUTATION"
    },
    "PRIMES": {
        "prefix": "PRIMES",
        "body": [
            "template <class T>",
            "inline bool ISPRIME(const T x) {",
            "  if (x <= 1) return false;",
            "  for (T i = 2; i * i <= x; i++)",
            "    if (x % i == 0) return false;",
            "  return true;",
            "}",
            "",
            "template <typename T>",
            "vector<T> DIVISOR(T n) {",
            "  vector<T> v;",
            "  for (T i = 1; i * i <= n; ++i) {",
            "    if (n % i == 0) {",
            "      v.push_back(i);",
            "      if (i != n / i) {",
            "        v.push_back(n / i);",
            "      }",
            "    }",
            "  }",
            "  sort(v.begin(), v.end());",
            "  return v;",
            "}",
            "",
            "template <typename T>",
            "vector<vector<T>> DIVISOR_ALL(T n) {",
            "  vector<vector<T>> res(n + 1);",
            "  for (T i = 1; i <= n; i++) {",
            "    for (T j = i; j <= n; j += i) {",
            "      res[j].push_back(i);",
            "    }",
            "  }",
            "  return res;",
            "}",
            "",
            "template <class T>",
            "vector<bool> ERATOSTHENES(const T n) {",
            "  vector<bool> arr(n + 1, true);",
            "  arr[0] = arr[1] = false;",
            "  for (T i = 2; i * i <= n; i++) {",
            "    if (arr[i]) {",
            "      for (T j = i * 2ll; j <= n; j += i) {",
            "        arr[j] = false;",
            "      }",
            "    }",
            "  }",
            "  return arr;",
            "}",
            "",
            "template <class T>",
            "vector<T> ERATOSTHENES_VALUE(const T n) {",
            "  vector<bool> primes = ERATOSTHENES(n);",
            "  vector<T> results;",
            "  for (int i = 0; i <= n; i++)",
            "    if (primes[i]) results.emplace_back(i);",
            "  return results;",
            "}",
            "",
            "// a <= x < b",
            "template <typename T>",
            "vector<bool> ERATOSTHENES(const T a, const T b) {",
            "  vector<bool> small = ERATOSTHENES(b);",
            "  vector<bool> prime(b - a, true);",
            "",
            "  for (T i = 2; i * i <= b; i++) {",
            "    if (small[i]) {",
            "      for (T j = max(2ll, (a + i - 1) / i) * i; j < b; j += i) {",
            "        prime[j - a] = false;",
            "      }",
            "    }",
            "  }",
            "",
            "  return prime;",
            "}",
            "",
            "// O(n (logn)^2)",
            "template <typename T>",
            "vector<T> SMALLEST_PRIME_FACTORS(T n) {",
            "  vector<T> spf(n + 1);",
            "  for (T i = 0; i <= n; i++) spf[i] = i;",
            "  for (T i = 2; i * i <= n; i++) {",
            "    if (spf[i] == i) {",
            "      for (T j = i * i; j <= n; j += i) {",
            "        spf[j] = i;",
            "      }",
            "    }",
            "  }",
            "  return spf;",
            "}",
            "",
            "template <typename T>",
            "vector<pair<T, T>> FACTORIZATION(T x) {",
            "  vector<pair<T, ll>> ans;",
            "  for (T i = 2; i * i <= x; i++) {",
            "    if (x % i == 0) {",
            "      T count = 0;",
            "      while (x % i == 0) {",
            "        count++;",
            "        x /= i;",
            "      }",
            "      ans.push_back(make_pair(i, count));",
            "    }",
            "  }",
            "  if (x != 1) ans.push_back(make_pair(x, 1));",
            "  return ans;",
            "}",
            "",
            "// O(logn)",
            "template <typename T>",
            "vector<T> FACTORIZATION(T x, vector<T> &spf) {",
            "  vector<T> ret;",
            "  while (x != 1) {",
            "    ret.push_back(spf[x]);",
            "    x /= spf[x];",
            "  }",
            "  sort(ret.begin(), ret.end());",
            "  return ret;",
            "}"
        ],
        "description": "description for PRIMES"
    },
    "REGEX": {
        "prefix": "REGEX",
        "body": [
            "bool REG_MATCH(string const &text, regex const &re) {",
            "  bool result = regex_match(text, re);",
            "  return result;",
            "}",
            "",
            "bool REG_MATCH(string const &text, smatch &match, regex const &re) {",
            "  bool result = regex_match(text, match, re);",
            "  return result;",
            "}",
            "",
            "smatch REG_SEARCH(string const &text, regex const &re) {",
            "  smatch m;",
            "  regex_search(text, m, re);",
            "  return m;",
            "}",
            "",
            "vector<smatch> REG_ALL_SEARCH(string const &text, regex const &re) {",
            "  vector<smatch> matchs;",
            "  sregex_iterator iter(text.cbegin(), text.cend(), re);",
            "  sregex_iterator end;",
            "  for (; iter != end; iter++) matchs.push_back(*iter);",
            "  return matchs;",
            "}",
            "",
            "string REG_REPLACE(string const &text, regex const &re, string const &replace) {",
            "  string result =",
            "      regex_replace(text, re, replace, regex_constants::format_first_only);",
            "  return result;",
            "}",
            "",
            "string REG_ALL_REPLACE(string const &text, regex const &re,",
            "                       string const &replace) {",
            "  string result = regex_replace(text, re, replace);",
            "  return result;",
            "}"
        ],
        "description": "description for REGEX"
    },
    "REROOTING": {
        "prefix": "REROOTING",
        "body": [
            "template <class T>",
            "class ReRooting {",
            " private:",
            "  int N;",
            "",
            "  // G[i][j]",
            "  // 頂点iのj番目に隣接している頂点",
            "  vector<vector<int>> G;",
            "",
            "  // idxs[i][j]",
            "  // G[i][j]頂点(頂点iのj番目に隣接している頂点)からみて、頂点iは何番目か",
            "  vector<vector<int>> idxs;",
            "",
            "  // result[i]",
            "  // 頂点iからの答え",
            "  vector<T> result;",
            "",
            "  // dp[i][j]",
            "  // 頂点iを親としたとき",
            "  // 頂点iに番目につながっている部分木G[i][j]以降の答え",
            "  vector<vector<T>> dp;",
            "",
            "  T identity;",
            "",
            "  // func(x, y)",
            "  // 値x,yを処理するモノイド",
            "  function<T(T, T)> func;",
            "",
            "  // add_node(x, u)",
            "  // 頂点uを根付き木としたときその子供のモノイドを計算した後の最後の一手",
            "  // u自体を加えるイメージ",
            "  function<T(T, int)> add_node;",
            "",
            " public:",
            "  ReRooting(int N, vector<pair<int, int>> &edges, T identity,",
            "            function<T(T, T)> func, function<T(T, int)> add_node)",
            "      : N(N), identity(identity), func(func), add_node(add_node) {",
            "    G = vector<vector<int>>(N);",
            "    idxs = vector<vector<int>>(N);",
            "",
            "    for (auto &&e : edges) {",
            "      int f = e.first;",
            "      int t = e.second;",
            "      idxs[f].push_back(G[t].size());",
            "      idxs[t].push_back(G[f].size());",
            "      G[f].push_back(t);",
            "      G[t].push_back(f);",
            "    }",
            "",
            "    dp = vector<vector<T>>(N);",
            "    result = vector<T>(N);",
            "    for (int i = 0; i < N; i++) dp[i] = vector<T>(G[i].size());",
            "",
            "    if (N > 1)",
            "      reroot();",
            "    else if (N == 1)",
            "      result[0] = add_node(identity, 0);",
            "  }",
            "",
            "  T query(int v) { return result[v]; }",
            "",
            " private:",
            "  void reroot() {",
            "    // parent[i] = iの親頂点",
            "    vector<int> parent(N);",
            "",
            "    // order[i] = 行きがけ順でi番目に訪れた頂点",
            "    vector<int> order;",
            "",
            "    // region init_ordered_tree",
            "",
            "    stack<int> stk;",
            "    stk.push(0);",
            "    parent[0] = -1;",
            "    while (!stk.empty()) {",
            "      auto v = stk.top();",
            "      stk.pop();",
            "      order.push_back(v);",
            "      for (auto to : G[v]) {",
            "        if (to == parent[v]) continue;",
            "        stk.push(to);",
            "        parent[to] = v;",
            "      }",
            "    }",
            "    // endregion",
            "",
            "    // region from_leaf (bottom-up)",
            "",
            "    for (int i = N - 1; i >= 1; i--) {",
            "      auto v = order[i];",
            "      auto p = parent[v];",
            "",
            "      // 親pとする部分木vの答え",
            "      T aum = identity;",
            "",
            "      // vの親pがvに何番目で隣接しているか",
            "      int p_idx = -1;",
            "",
            "      for (int j = 0; j < G[v].size(); j++) {",
            "        if (G[v][j] == p) {",
            "          p_idx = j;",
            "          continue;",
            "        }",
            "        aum = func(aum, dp[v][j]);",
            "      }",
            "",
            "      // 親pにとって、頂点vはidxs[v][p_idx]番目にある",
            "      dp[p][idxs[v][p_idx]] = add_node(aum, v);",
            "    }",
            "    // endregion",
            "",
            "    // region to_leaf(top-down)",
            "    for (int i = 0; i < N; i++) {",
            "      auto v = order[i];",
            "      T aum = identity;",
            "",
            "      // tails[i]",
            "      // 頂点vの最後から 先頭から数えてi番目に隣接している頂点までの値",
            "      vector<T> tails(G[v].size());",
            "      tails.back() = identity;",
            "",
            "      for (int j = tails.size() - 1; j >= 1; j--)",
            "        tails[j - 1] = func(dp[v][j], tails[j]);",
            "      for (int j = 0; j < tails.size(); j++) {",
            "        dp[G[v][j]][idxs[v][j]] = add_node(func(aum, tails[j]), v);",
            "        aum = func(aum, dp[v][j]);",
            "      }",
            "",
            "      result[v] = add_node(aum, v);",
            "    }",
            "    // endregion",
            "  }",
            "};"
        ],
        "description": "description for REROOTING"
    },
    "SEGMENT": {
        "prefix": "SEGMENT",
        "body": [
            "template <typename T>",
            "struct SegmentTree {",
            " private:",
            "  using Func = function<T(T, T)>;",
            "",
            "  int n;",
            "  vector<T> node;",
            "",
            "  T init_v;",
            "  Func func;",
            "",
            " public:",
            "  SegmentTree(vector<T> a, Func _func, T _init_v) {",
            "    int sz = a.size();",
            "    n = 1;",
            "    init_v = _init_v;",
            "    func = _func;",
            "",
            "    while (n < sz) n *= 2;",
            "    node.resize(2 * n, init_v);",
            "    for (int i = 0; i < sz; i++) node[i + n - 1] = a[i];",
            "    for (int i = n - 2; i >= 0; i--)",
            "      node[i] = func(node[i * 2 + 1], node[i * 2 + 2]);",
            "  }",
            "",
            "  void update(int pos, T v) {",
            "    int k = pos + n - 1;",
            "    node[k] = v;",
            "    while (k > 0) {",
            "      k = (k - 1) / 2;",
            "      node[k] = func(node[k * 2 + 1], node[k * 2 + 2]);",
            "    }",
            "  }",
            "",
            "  T get(int pos) {",
            "    int k = pos + n - 1;",
            "    return node[k];",
            "  }",
            "",
            "  T query(int a, int b, int k = 0, int l = 0, int r = -1) {",
            "    if (r < 0) r = n;",
            "    if (r <= a || b <= l) return init_v;",
            "    if (a <= l && r <= b) return node[k];",
            "    T lv = query(a, b, k * 2 + 1, l, (l + r) / 2);",
            "    T rv = query(a, b, k * 2 + 2, (l + r) / 2, r);",
            "    return func(lv, rv);",
            "  }",
            "};"
        ],
        "description": "description for SEGMENT"
    },
    "SLIDE": {
        "prefix": "SLIDE",
        "body": [
            "for (int i = 0; i < $d$; i++) {",
            "}",
            "",
            "for (int i = 0; i < $N$ - $d$; i++) {",
            "  // erase left i",
            "",
            "  // add right i + d",
            "}"
        ],
        "description": "description for SLIDE"
    },
    "SPARSE_TABLE": {
        "prefix": "SPARSE_TABLE",
        "body": [
            "template <typename T>",
            "struct SparseTable {",
            "  int n;",
            "  int h;",
            "  vector<T> a;",
            "",
            "  /// @param log_table log_table[k] = floor(log(k))",
            "  vector<T> log_table;",
            "",
            "  /// @brief 0-index original",
            "  /// @param table table[i][k] = iから2^kの範囲のargmin",
            "  vector<vector<T>> table;",
            "  SparseTable() = default;",
            "  SparseTable(const vector<T> a) { init(a); }",
            "",
            "  void init(vector<T> _a) {",
            "    a = _a;",
            "    n = a.size();",
            "    h = 0;",
            "    // nをなめるために必要な幅 ceil(log(n/2))",
            "    while ((1 << h) < n) ++h;",
            "    h++;",
            "    table = vector<vector<T>>(1 << h, vector<T>(h));",
            "    log_table = vector<T>(n + 1, 0);",
            "    for (int i = 2; i <= n; i++) log_table[i] = log_table[i >> 1] + 1;",
            "    for (int i = 0; i < n; i++) table[i][0] = i;",
            "    for (int k = 1; k < h; k++) {",
            "      for (int i = 0; i < n; i++) {",
            "        int left = table[i][k - 1];",
            "        int right = table[min(i + (1 << (k - 1)), n - 1)][k - 1];",
            "        if (a[left] < a[right])",
            "          table[i][k] = left;",
            "        else",
            "          table[i][k] = right;",
            "      }",
            "    }",
            "  }",
            "",
            "  /// @param l original close [",
            "  /// @param r original open )",
            "  /// @brief argmin a[l, r)",
            "  T get(int l, int r) {",
            "    int lp = table[l][log_table[r - l]];",
            "    int rp = table[r - (1 << log_table[r - l])][log_table[r - l]];",
            "    if (a[lp] < a[rp])",
            "      return lp;",
            "    else",
            "      return rp;",
            "  }",
            "",
            "  void show() {",
            "    for (int k = 0; k < h; k++) {",
            "      printf(\"k = %d\\n\", k);",
            "      for (int i = 0; i < n; i++) {",
            "        printf(\"%3d \", table[i][k]);",
            "      }",
            "      printf(\"\\n\\n\");",
            "    }",
            "  }",
            "};"
        ],
        "description": "description for SPARSE_TABLE"
    },
    "STRONG_CONNECTED_COMPONENTS": {
        "prefix": "STRONG_CONNECTED_COMPONENTS",
        "body": [
            "template <typename G>",
            "struct StrongConnectedComponents {",
            "  /// @bried graph SCCする元グラフ",
            "  const G &graph;",
            "  int V;",
            "",
            "  /// @brief graph SCC用の内部グラフ",
            "  UnWeightedGraph go_g, rv_g;",
            "",
            "  /// @brief comp comp[v] = vの所属するSCCの番号 トポロジカル順",
            "  vector<int> comp;",
            "",
            "  /// @brief dfs用",
            "  vector<bool> used;",
            "",
            "  /// @brief dfsの帰りがけ順",
            "  vector<int> order;",
            "",
            "  StrongConnectedComponents(G &graph)",
            "      : graph(graph),",
            "        V(graph.size()),",
            "        go_g(V),",
            "        rv_g(V),",
            "        comp(V, -1),",
            "        used(V, false) {",
            "    for (int i = 0; i < V; i++) {",
            "      for (auto e : graph[i]) {",
            "        go_g[i].emplace_back((int)e);",
            "        rv_g[(int)e].emplace_back(i);",
            "      }",
            "    }",
            "  }",
            "",
            "  /// @brief 頂点vの所属するSCCのIDのを返す",
            "  int operator[](int v) { return comp[v]; }",
            "",
            "  void dfs(int v) {",
            "    if (used[v]) return;",
            "    used[v] = true;",
            "    for (auto to : go_g[v]) dfs(to);",
            "    order.emplace_back(v);",
            "  }",
            "",
            "  void rdfs(int v, int cnt) {",
            "    if (comp[v] != -1) return;",
            "    comp[v] = cnt;",
            "    for (auto to : rv_g[v]) rdfs(to, cnt);",
            "  }",
            "",
            "  vector<int> get_comp() const { return comp; }",
            "",
            "  /// @param gt 参照で空グラフを与える gt[SCCID]が繋がる他の頂点",
            "  void build(UnWeightedGraph &gt) {",
            "    for (int i = 0; i < V; i++) dfs(i);",
            "    reverse(order.begin(), order.end());",
            "    int cnt = 0;",
            "    for (auto v : order)",
            "      if (comp[v] == -1) rdfs(v, cnt), cnt++;",
            "    gt.resize(cnt);",
            "    for (int i = 0; i < V; i++) {",
            "      for (auto &to : graph[i]) {",
            "        int x = comp[i];",
            "        int y = comp[(int)to];",
            "        if (x == y) continue;",
            "        gt[x].push_back(y);",
            "      }",
            "    }",
            "  }",
            "};"
        ],
        "description": "description for STRONG_CONNECTED_COMPONENTS"
    },
    "SUFFIX_ARRAY": {
        "prefix": "SUFFIX_ARRAY",
        "body": [
            "/// @details n (logn)^2",
            "class Suffix_Array {",
            " private:",
            "  int n;",
            "",
            "  /// @brief |S[0:]|=n",
            "  /// @brief |S[n:]|=0",
            "  string S;",
            "",
            "  /// @brief 0-index",
            "  /// @details SA[j] = S[i:]の接尾辞の昇順ソートされた元の位置i",
            "  /// @details SA[0] = \"\"",
            "  vector<int> SA;",
            "",
            "  /// @brief 0-index",
            "  /// @details rank[SA[j]] = kのrank分かっている時の2kのrank比較",
            "  /// 元の位置S[(i=SA[j]):]のランク",
            "  vector<int> rank;",
            "",
            "  /// @details rank計算用",
            "  vector<int> tmp;",
            "",
            "  bool lb_substr(const string &pat, int si = 0, int ti = 0) {",
            "    int sn = n;",
            "    int tn = pat.size();",
            "    while (si < sn && ti < tn) {",
            "      if (S[si] < pat[ti]) return true;",
            "      if (S[si] > pat[ti]) return false;",
            "      ++si, ++ti;",
            "    }",
            "    return si >= sn && ti < tn;",
            "  }",
            "",
            " public:",
            "  Suffix_Array(const string s) {",
            "    S = s;",
            "    n = s.size();",
            "    SA = vector<int>(n + 1);",
            "    rank = vector<int>(n + 1);",
            "    tmp = vector<int>(n + 1);",
            "    construct();",
            "  }",
            "",
            "  void construct() {",
            "    int k = 1;",
            "",
            "    /// @param i 元の文字列Sの位置i S[i:]",
            "    /// @param j 元の文字列Sの位置j S[j:]",
            "    auto comp = [&](int i, int j) {",
            "      if (rank[i] != rank[j])",
            "        return rank[i] < rank[j];",
            "      else {",
            "        int ri = i + k <= n ? rank[i + k] : -1;",
            "        int rj = j + k <= n ? rank[j + k] : -1;",
            "        return ri < rj;",
            "      }",
            "    };",
            "",
            "    for (int i = 0; i <= n; i++) {",
            "      SA[i] = i;",
            "      rank[i] = i < n ? S[i] : -1;",
            "    }",
            "",
            "    for (k = 1; k <= n; k *= 2) {",
            "      sort(SA.begin(), SA.end(), comp);",
            "",
            "      tmp[SA[0]] = 0;",
            "      for (int i = 1; i <= n; i++)",
            "        tmp[SA[i]] = tmp[SA[i - 1]] + (comp(SA[i - 1], SA[i]) ? 1 : 0);",
            "      for (int i = 0; i <= n; i++) rank[i] = tmp[i];",
            "    }",
            "  }",
            "",
            "  /// @param pat Sに含まれるか調べる文字列パターン",
            "  /// @brief O(|pat|log|S|)",
            "  bool contain(const string &pat) {",
            "    int low = 0;",
            "    int high = n;",
            "    while (high - low > 1) {",
            "      int c = (low + high) / 2;",
            "      if (S.compare(SA[c], pat.length(), pat) < 0)",
            "        low = c;  // S[SA[c]:] < T",
            "      else",
            "        high = c;  // S[SA[c]:] >= T",
            "    }",
            "    return S.compare(SA[high], pat.length(), pat) == 0;",
            "  }",
            "",
            "  /// @param pat 文字列パターン",
            "  /// @details 1 ~ n 正常(0は空文字)",
            "  /// @details n + 1 .end()",
            "  /// @details SA[high:]が下限",
            "  int lower_bound(const string &pat) {",
            "    int low = 0;",
            "    int high = n + 1;",
            "    while (high - low > 1) {",
            "      int mid = (low + high) / 2;",
            "      if (lb_substr(pat, SA[mid]))",
            "        low = mid;",
            "      else",
            "        high = mid;",
            "    }",
            "    return high;",
            "  }",
            "",
            "  /// @param pat 文字列パターン",
            "  /// @details 1 ~ n 正常(0は空文字)",
            "  /// @details n + 1 .end()",
            "  /// @details SA[:high)が上限",
            "  int upper_bound(string &pat) {",
            "    int low = 0;",
            "    int high = n + 1;",
            "    pat.back()++;",
            "    while (high - low > 1) {",
            "      int mid = (low + high) / 2;",
            "      if (lb_substr(pat, SA[mid]))",
            "        low = mid;",
            "      else",
            "        high = mid;",
            "    }",
            "    pat.back()--;",
            "    return high;",
            "  }",
            "",
            "  vector<int> get_SA() const { return SA; }",
            "",
            "  string get_S() const { return S; }",
            "",
            "  void show_SA() {",
            "    printf(\"alphabetical order\\n\");",
            "    printf(\"i :\");",
            "    for (int i = 0; i <= n; i++) printf(\"%3d\", i);",
            "    printf(\"\\n\");",
            "    printf(\"SA:\");",
            "    for (int i = 0; i <= n; i++) printf(\"%3d\", SA[i]);",
            "    printf(\"\\n\");",
            "    printf(\"L :\");",
            "    for (int i = 0; i <= n; i++) printf(\"%3d\", n - SA[i]);",
            "    printf(\"\\n\\n\");",
            "  }",
            "};"
        ],
        "description": "description for SUFFIX_ARRAY"
    },
    "TEXT": {
        "prefix": "TEXT",
        "body": [
            "vector<string> SPRIT(const string &s, const string &delim) {",
            "  vector<string> result;",
            "  string::size_type pos = 0;",
            "  while (pos != string::npos) {",
            "    string::size_type p = s.find(delim, pos);",
            "    if (p == string::npos) {",
            "      result.push_back(s.substr(pos));",
            "      break;",
            "    } else {",
            "      result.push_back(s.substr(pos, p - pos));",
            "    }",
            "    pos = p + delim.size();",
            "  }",
            "  return result;",
            "}",
            "",
            "string TRIM(const string &str, const char *trimCharacterList = \" \\t\\v\\r\\n\") {",
            "  string result;",
            "  string::size_type left = str.find_first_not_of(trimCharacterList);",
            "  if (left != string::npos) {",
            "    string::size_type right = str.find_last_not_of(trimCharacterList);",
            "    result = str.substr(left, right - left + 1);",
            "  }",
            "  return result;",
            "}",
            "",
            "string LTRIM(const string &str, const string trimCharacterList = \" \\t\\v\\r\\n\") {",
            "  size_t start = str.find_first_not_of(trimCharacterList);",
            "  return (start == std::string::npos) ? \"\" : str.substr(start);",
            "}",
            "",
            "string RTRIM(const string &str, const string trimCharacterList = \" \\t\\v\\r\\n\") {",
            "  size_t end = str.find_last_not_of(trimCharacterList);",
            "  return (end == std::string::npos) ? \"\" : str.substr(0, end + 1);",
            "}",
            "",
            "string REPLACE_STRING(const string &source, const string &find,",
            "                      const string &alt) {",
            "  string result = source;",
            "  string::size_type pos = 0;",
            "  while (pos = result.find(find, pos), pos != string::npos) {",
            "    result.replace(pos, find.length(), alt);",
            "    pos += alt.length();",
            "  }",
            "  return result;",
            "}"
        ],
        "description": "description for TEXT"
    },
    "TSP": {
        "prefix": "TSP",
        "body": [
            "class TSP {",
            " private:",
            "  int V;",
            "  int start;",
            "  const WeightedGraph<ll> &G;",
            "  vector<vector<ll>> dp;",
            "",
            " public:",
            "  TSP(const WeightedGraph<ll> &G, int start) : G(G), V(G.size()), start(start) {",
            "    dp = vector<vector<ll>>(1 << V, vector<ll>(V, -1));",
            "  }",
            "",
            "  /// 閉路を構築する場合のコスト",
            "  /// \\param v 初期頂点",
            "  /// \\param S これまでに訪れた頂点",
            "  /// \\return これまでにS訪れたときにv以降の~Sでかかるコスト",
            "  ll all_dfs(int v, int S) {",
            "    if (dp[S][v] != -1) return dp[S][v];",
            "    if (S == (1 << V) - 1) {",
            "      if (v == start)",
            "        return 0;",
            "      else",
            "        return INF;",
            "    }",
            "    auto &ret = dp[S][v];",
            "    ret = INF;",
            "    for (auto &e : G[v]) {",
            "      int to = e.to;",
            "      if (v == to) continue;",
            "      if (S >> to & 1) continue;",
            "      chmin(ret, all_dfs(to, S | (1 << to)) + e.cost);",
            "    }",
            "    return ret;",
            "  }",
            "",
            "  /// 閉路を構築しない場合のコスト",
            "  /// part_dfs(v, 1<< v)のように呼び出す",
            "  /// \\param v 初期頂点",
            "  /// \\param S これまでに訪れた頂点",
            "  /// \\return これまでにS訪れたときにv以降の~Sでかかるコスト",
            "  ll part_dfs(int v, int S) {",
            "    if (dp[S][v] != -1) return dp[S][v];",
            "    if (S == (1 << V) - 1) return 0;",
            "    auto &ret = dp[S][v];",
            "    ret = INF;",
            "    for (auto &e : G[v]) {",
            "      int to = e.to;",
            "      if (v == to) continue;",
            "      if (S >> to & 1) continue;",
            "      chmin(ret, part_dfs(to, S | (1 << to)) + e.cost);",
            "    }",
            "    return ret;",
            "  }",
            "",
            "  vector<vector<ll>> get_dist() { return dp; }",
            "};"
        ],
        "description": "description for TSP"
    },
    "UNION_FIND": {
        "prefix": "UNION_FIND",
        "body": [
            "struct UnionFind {",
            "  vector<int> par;",
            "  vector<int> sizes;",
            "",
            "  UnionFind(int n) : par(n), sizes(n, 1) {",
            "    for (int i = 0; i < n; i++) {",
            "      par[i] = i;",
            "    }",
            "  }",
            "",
            "  int find(int x) { return x == par[x] ? x : par[x] = find(par[x]); }",
            "",
            "  bool unite(int x, int y) {",
            "    x = find(x);",
            "    y = find(y);",
            "    if (x == y) return false;",
            "    if (sizes[x] < sizes[y]) swap(x, y);",
            "    par[y] = x;",
            "    sizes[x] += sizes[y];",
            "    return true;",
            "  }",
            "",
            "  bool same(int x, int y) { return find(x) == find(y); }",
            "",
            "  int get_size(int x) { return sizes[find(x)]; }",
            "",
            "  bool all_same() {",
            "    bool good = true;",
            "    for (int i = 0, n = par.size(); i < n; i++)",
            "      if (find(0) != find(i)) good = false;",
            "    return good;",
            "  }",
            "",
            "  int get_connectivity() {",
            "    set<int> s;",
            "    for (int i = 0, n = par.size(); i < n; i++) s.insert(find(i));",
            "    return s.size();",
            "  }",
            "};"
        ],
        "description": "description for UNION_FIND"
    },
    "UNION_FIND_MINMAX": {
        "prefix": "UNION_FIND_MINMAX",
        "body": [
            "struct UnionFindMaxMin {",
            "  vector<int> par;",
            "  vector<int> sizes;",
            "  vector<int> maxs;",
            "  vector<int> mins;",
            "",
            "  UnionFindMaxMin(int n) : par(n), sizes(n, 1), maxs(n), mins(n) {",
            "    REP(i, n) par[i] = i;",
            "    REP(i, n) maxs[i] = i;",
            "    REP(i, n) mins[i] = i;",
            "  }",
            "",
            "  int find(int x) {",
            "    if (x == par[x])",
            "      return x;",
            "    else",
            "      return par[x] = find(par[x]);",
            "  }",
            "",
            "  void unite(int x, int y) {",
            "    x = find(x);",
            "    y = find(y);",
            "    if (x == y) return;",
            "    if (sizes[x] < sizes[y]) swap(x, y);",
            "    par[y] = x;",
            "    maxs[x] = max(maxs[y], maxs[x]);",
            "    mins[x] = min(mins[y], mins[x]);",
            "    sizes[x] += sizes[y];",
            "  }",
            "",
            "  bool same(int x, int y) { return find(x) == find(y); }",
            "",
            "  int size(int x) { return sizes[find(x)]; }",
            "",
            "  int getMax(int x) { return maxs[find(x)]; }",
            "",
            "  int getMin(int x) { return mins[find(x)]; }",
            "};"
        ],
        "description": "description for UNION_FIND_MINMAX"
    },
    "WARSHALL_FLOYD": {
        "prefix": "WARSHALL_FLOYD",
        "body": [
            "template <class T>",
            "class WarshallFloyd {",
            "  int N;",
            "  DistMatrix<T> matrix;",
            "  T INF;",
            "",
            " public:",
            "  WarshallFloyd(const DistMatrix<T> matrix, const T INF)",
            "      : matrix(matrix), N(matrix.size()), INF(INF) {",
            "    build();",
            "  }",
            "",
            "  void build() {",
            "    for (int i = 0; i < N; i++) matrix[i][i] = 0;",
            "    for (int k = 0; k < N; k++) {",
            "      for (int i = 0; i < N; i++) {",
            "        for (int j = 0; j < N; j++) {",
            "          if (matrix[i][k] == INF || matrix[k][j] == INF) continue;",
            "          matrix[i][j] = min(matrix[i][j], matrix[i][k] + matrix[k][j]);",
            "        }",
            "      }",
            "    }",
            "  }",
            "",
            "  DistMatrix<T> get_matrix() const { return matrix; }",
            "",
            "  bool has_minus_cycle() const {",
            "    bool is_minus = false;",
            "    for (int i = 0; i < N; i++)",
            "      if (matrix[i][i] < 0) is_minus = true;",
            "    return is_minus;",
            "  }",
            "",
            "  void show() const {",
            "    for (int i = 0; i < N; i++) {",
            "      for (int j = 0; j < N; j++) {",
            "        printf(\"%4lld \", matrix[i][j]);",
            "      }",
            "      cout << endl;",
            "    }",
            "    cout << endl;",
            "  }",
            "};"
        ],
        "description": "description for WARSHALL_FLOYD"
    },
    "Z_ALGO": {
        "prefix": "Z_ALGO",
        "body": [
            "/// @details O(|S|)",
            "class Z_Algo {",
            " private:",
            "  int len;",
            "  string S;",
            "  vector<int> Z;",
            "",
            " public:",
            "  Z_Algo(const string s) {",
            "    len = s.size();",
            "    S = s;",
            "    Z = vector<int>(len);",
            "    build();",
            "  }",
            "",
            "  void build() {",
            "    Z[0] = len;",
            "    int i = 1, j = 0;",
            "    while (i < len) {",
            "      while (i + j < len && S[j] == S[i + j]) ++j;",
            "      Z[i] = j;",
            "      if (j == 0) {",
            "        i++;",
            "        continue;",
            "      }",
            "      int k = 1;",
            "      while (i + k < S.size() && k + Z[k] < j) Z[i + k] = Z[k], k++;",
            "      i += k;",
            "      j -= k;",
            "    }",
            "  }",
            "",
            "  int get_max() const { return *max_element(Z.begin(), Z.end()); }",
            "",
            "  vector<int> get_result() { return Z; }",
            "",
            "  int operator[](int k) const { return Z[k]; }",
            "",
            "  void show() const {",
            "    printf(\"i:\");",
            "    for (int i = 0; i < len; i++) printf(\"%3d \", i);",
            "    printf(\"\\n\");",
            "    printf(\"Z:\");",
            "    for (int i = 0; i < len; i++) printf(\"%3d \", Z[i]);",
            "    printf(\"\\n\");",
            "  }",
            "};"
        ],
        "description": "description for Z_ALGO"
    },
    "ROLLING_HASH": {
        "prefix": "ROLLING_HASH",
        "body": [
            "struct RollingHash {",
            "  using long_type = unsigned;",
            "  using hash_type = tuple<long_type, long_type, long_type>;",
            "",
            " private:",
            "  int s_len;",
            "",
            "  long_type mod1;",
            "  long_type mod2;",
            "  long_type mod3;",
            "",
            "  long_type base1;",
            "  long_type base2;",
            "  long_type base3;",
            "",
            "  vector<long_type> hash1;",
            "  vector<long_type> hash2;",
            "  vector<long_type> hash3;",
            "",
            "  vector<long_type> pow1;",
            "  vector<long_type> pow2;",
            "  vector<long_type> pow3;",
            "",
            " public:",
            "  RollingHash()",
            "      : base1(1009),",
            "        base2(1007),",
            "        base3(2339),",
            "        mod1(1000000007),",
            "        mod2(1000000009),",
            "        mod3(1000000087) {}",
            "",
            "  RollingHash(const string s) : RollingHash() { init(s); }",
            "",
            "  void init(const string s) {",
            "    const int n = s.size();",
            "    s_len = n;",
            "",
            "    hash1.assign(n + 1, 0);",
            "    hash2.assign(n + 1, 0);",
            "    hash3.assign(n + 1, 0);",
            "    pow1.assign(n + 1, 1);",
            "    pow2.assign(n + 1, 1);",
            "    pow3.assign(n + 1, 1);",
            "",
            "    for (int i = 0; i < n; i++) {",
            "      hash1[i + 1] = ((hash1[i] + s[i]) * base1);",
            "      hash2[i + 1] = ((hash2[i] + s[i]) * base2);",
            "      hash3[i + 1] = ((hash3[i] + s[i]) * base3);",
            "      pow1[i + 1] = (pow1[i] * base1);",
            "      pow2[i + 1] = (pow2[i] * base2);",
            "      pow3[i + 1] = (pow3[i] * base3);",
            "    }",
            "  }",
            "",
            "  // 0-index",
            "  // s[l, r)のハッシュタプルを返す",
            "  hash_type get_hash_tuple(int l, int r) {",
            "    long_type h1 =",
            "        ((hash1[r] - hash1[l] * pow1[r - l] + mod1) % mod1 + mod1) % mod1;",
            "    long_type h2 =",
            "        ((hash2[r] - hash2[l] * pow2[r - l] + mod2) % mod2 + mod2) % mod2;",
            "    long_type h3 =",
            "        ((hash3[r] - hash3[l] * pow3[r - l] + mod3) % mod3 + mod3) % mod3;",
            "    return make_tuple(h1, h2, h3);",
            "  }",
            "",
            "  // not verify",
            "  // htype_1のハッシュの後ろに長さh2_lenのハッシュを結合する",
            "  hash_type concat(hash_type h_tup1, hash_type h_tup2, int h2_len) {",
            "    long_type h1 = (get<0>(h_tup1) * pow1[h2_len] + get<0>(h_tup2)) % mod1;",
            "    long_type h2 = (get<1>(h_tup1) * pow2[h2_len] + get<1>(h_tup2)) % mod2;",
            "    long_type h3 = (get<2>(h_tup1) * pow3[h2_len] + get<2>(h_tup2)) % mod3;",
            "    return make_tuple(h1, h2, h3);",
            "  }",
            "",
            "  //先頭i文字のハッシュタプルを返す",
            "  hash_type get_from_head(int len) { return get_hash_tuple(0, len); }",
            "",
            "  //末尾i文字のハッシュタプルを返す",
            "  hash_type get_from_tail(int len) {",
            "    return get_hash_tuple(s_len - len, s_len);",
            "  }",
            "",
            "  // sを含む個数の計算",
            "  int contain(string s) {",
            "    int ret = 0;",
            "    int m_len = this->s_len;",
            "    int o_len = s.size();",
            "    RollingHash o_hash(s);",
            "    for (int i = 0; i < m_len - o_len + 1; i++) {",
            "      auto h1 = get_hash_tuple(i, i + o_len);",
            "      auto h2 = o_hash.get_hash_tuple(0, o_len);",
            "      if (RollingHash::same(h1, h2)) ret++;",
            "    }",
            "    return ret;",
            "  }",
            "",
            "  static bool same(hash_type h_tup1, hash_type h_tup2) {",
            "    return h_tup1 == h_tup2;",
            "  }",
            "};"
        ],
        "description": "description for ROLLING_HASH"
    }
}